<!DOCTYPE html>

<head>
  <meta charset="utf-8" />
</head>

<body>
  <div id="main"></div>
</body>

<style>
  :root {
    --color-fileSelectBorder: #aaaaaa;
    --color-border: #555555;
    --color-background: #000000;
    --color-selected: #670033;
    --color-text: #dddddd;
    --color-error: #ff0000;
  }

  [theme="light"] {
    --color-fileSelectBorder: #000000;
    --color-border: #999999;
    --color-background: #ffffff;
    --color-selected: #ff69b4;
    --color-text: #000000;
    --color-error: #a30000;
  }

  /* Scrollbars */
  ::-webkit-scrollbar {
    width: 7px;
  }

  ::-webkit-scrollbar-track,
  ::-webkit-scrollbar-corner {
    background: var(--color-background);
  }

  ::-webkit-scrollbar-thumb {
    background: var(--color-border);
  }

  ::-webkit-scrollbar-thumb:hover {
    background: var(--color-selected);
  }

  html,
  html * {
    scrollbar-color: var(--color-border) var(--color-background);
    scrollbar-width: thin;
  }

  /* Range input */
  input[type="range"] {
    color: inherit;
    background-color: inherit;
    height: 20px;
    -webkit-appearance: none;
    width: 100%;
  }
  input[type="range"]:focus {
    outline: none;
  }
  input[type="range"]::-webkit-slider-runnable-track {
    width: 100%;
    height: 16px;
    cursor: pointer;
    background: var(--color-border);
  }
  input[type="range"]::-webkit-slider-thumb {
    height: 20px;
    width: 20px;
    background: var(--color-border);
    cursor: pointer;
    -webkit-appearance: none;
    margin-top: -2px;
    border: 1px solid var(--color-text);
  }
  input[type="range"]::-moz-range-track {
    width: 100%;
    height: 16px;
    cursor: pointer;
    background: var(--color-border);
  }
  input[type="range"]::-moz-range-thumb {
    height: 20px;
    width: 20px;
    background: var(--color-border);
    cursor: pointer;
    border: 1px solid var(--color-text);
  }
  input[type="range"]::-ms-track {
    width: 100%;
    height: 16px;
    cursor: pointer;
    background: transparent;
    border-color: transparent;
    color: transparent;
  }
  input[type="range"]::-ms-fill-lower {
    background: var(--color-border);
    border-radius: 50px;
    box-shadow: 0px 0px 0px #000000;
  }
  input[type="range"]::-ms-fill-upper {
    background: var(--color-border);
    border-radius: 50px;
    box-shadow: 0px 0px 0px #000000;
  }
  input[type="range"]::-ms-thumb {
    margin-top: 1px;
    border: 1px solid var(--color-text);
    height: 20px;
    width: 20px;
    background: var(--color-border);
    cursor: pointer;
  }
</style>

<script>
  let XMLNS = "http://www.w3.org/2000/svg"

  const arrAsc = (arr) => {
    return arr.sort((a, b) => a - b)
  }

  const arrSum = (arr) => {
    return arr.reduce((a, b) => a + b, 0)
  }

  const arrCumSum = (arr) => {
    let result = []
    let current = 0
    for (val of arr) {
      current += val
      result.push(current)
    }
    return result
  }

  const arrMean = (arr) => {
    return arrSum(arr) / arr.length
  }

  const arrSd = (arr) => {
    const mu = arrMean(arr)
    const diffArr = arr.map((a) => (a - mu) ** 2)
    return Math.sqrt(arrSum(diffArr) / (arr.length - 1))
  }

  const arrSortedAscQuantile = (sorted, q) => {
    const pos = (sorted.length - 1) * q
    const base = Math.floor(pos)
    const rest = pos - base
    let result = sorted[base]
    if (sorted[base + 1] !== undefined) {
      result += rest * (sorted[base + 1] - sorted[base])
    }
    return result
  }

  const arrQuantile = (arr, q) => {
    return arrSortedAscQuantile(arrAsc(arr), q)
  }

  const arrSortedAscMin = (sorted) => {
    return sorted[0]
  }

  const arrSortedAscMax = (sorted) => {
    return sorted[sorted.length - 1]
  }

  const arrUnique = (arr) => {
    return Array.from(new Set(arr))
  }

  const groupByOne = (rows, key) => {
    let result = {}
    for (let row of rows) {
      if (result[row[key]] === undefined) {
        result[row[key]] = []
      }
      result[row[key]].push(row)
    }
    return result
  }

  const groupByMultiple = (rows, keys) => {
    let result = {}
    for (let row of rows) {
      let current = result
      for (let [keyIndex, key] of keys.entries()) {
        if (current[row[key]] === undefined) {
          if (keyIndex === keys.length - 1) {
            current[row[key]] = []
          } else {
            current[row[key]] = {}
          }
        }
        if (keyIndex === keys.length - 1) {
          current[row[key]].push(row)
        }
        current = current[row[key]]
      }
    }
    return result
  }

  const summariseGrouped = (data, groupVars, func) => {
    const calcRow = (data, currentRow) => {
      let result = []
      if (Array.isArray(data)) {
        if (data.length > 0) {
          let summarized = func(data)
          result = [{ ...currentRow, ...summarized }]
        }
      } else {
        let currentVarname = groupVars[Object.keys(currentRow).length]
        for (let key of Object.keys(data)) {
          currentRow[currentVarname] = key
          let row = calcRow(data[key], { ...currentRow })
          if (row.length > 0) {
            result = result.concat(row)
          }
        }
      }
      return result
    }
    return calcRow(data, {})
  }

  const stringSort = (s1, s2) => (s1 > s2 ? 1 : s1 < s2 ? -1 : 0)

  const desiredOrderSort = (ord) => {
    return (a, b) => {
      result = 0
      let ai = ord.indexOf(a)
      let bi = ord.indexOf(b)
      if (ai !== -1 || bi !== -1) {
        if (ai === -1) {
          result = 1
        } else if (bi === -1) {
          result = -1
        } else if (ai > bi) {
          result = 1
        } else if (ai < bi) {
          result = -1
        }
      }
      return result
    }
  }

  const scale = (value, valueMin, valueMax, scaleMin, scaleMax) => {
    let result = scaleMin
    let scaleRange = scaleMax - scaleMin
    if (scaleRange !== 0) {
      result = scaleRange / 2 + scaleMin
      let valueRange = valueMax - valueMin
      if (valueRange !== 0) {
        let value0 = value - valueMin
        let valueNorm = value0 / valueRange
        let valueScale0 = valueNorm * scaleRange
        result = valueScale0 + scaleMin
      }
    }
    return result
  }

  const parseData = (input) => {
    let result = []
    if (input.length > 0) {
      let lines = input.split(/\r?\n/).filter((line) => line !== "")
      let linesSplit = lines.map((line) => line.split(","))
      let names = linesSplit[0]
      if (linesSplit.length > 1) {
        for (let values of linesSplit.slice(1)) {
          let row = {}
          for (let [index, name] of names.entries()) {
            let value = values[index]
            if (name === "titre" || name === "clade_freq") {
              value = parseFloat(value)
            }
            row[name] = value
          }
          result.push(row)
        }
      }
    }
    return result
  }

  const reduceAxisPadBottom = (newValue, oldSizes) => {
    sizes = { ...oldSizes }
    sizes.plotHeight -= sizes.axisPadBottom - newValue
    sizes.axisPadBottom = newValue
    return sizes
  }

  const colChannel255ToString = (channel) => {
    return channel.toString(16).padStart(2, "0")
  }

  const colChangeSaturation = (col, satDelta) => {
    let alpha = col.slice(7, 9)
    let red = parseInt(col.slice(1, 3), 16)
    let green = parseInt(col.slice(3, 5), 16)
    let blue = parseInt(col.slice(5, 7), 16)

    let mean = (red + green + blue) / 3

    red = (red - mean) * satDelta + mean
    green = (green - mean) * satDelta + mean
    blue = (blue - mean) * satDelta + mean

    red = Math.max(Math.min(Math.round(red), 255), 0)
    green = Math.max(Math.min(Math.round(green), 255), 0)
    blue = Math.max(Math.min(Math.round(blue), 255), 0)

    let redNew = colChannel255ToString(red)
    let greenNew = colChannel255ToString(green)
    let blueNew = colChannel255ToString(blue)

    return "#" + redNew + greenNew + blueNew + alpha
  }

  const createTitreAxisElement = (
    colors,
    plotWidth,
    sizes,
    scaleTitre,
    title
  ) => {
    let titreAxis = document.createElementNS(XMLNS, "g")

    // NOTE(sen) Title
    let yTitle = document.createElementNS(XMLNS, "text")
    yTitle.setAttributeNS(null, "x", 0)
    yTitle.setAttributeNS(null, "y", 0)
    yTitle.setAttributeNS(null, "fill", colors.text)
    yTitle.setAttributeNS(
      null,
      "transform",
      `translate(${0}, ${
        (sizes.plotHeight - sizes.axisPadBottom) / 2
      }) rotate(-90)`
    )
    yTitle.setAttributeNS(null, "dominant-baseline", "hanging")
    yTitle.setAttributeNS(null, "text-anchor", "middle")
    yTitle.innerHTML = title
    titreAxis.appendChild(yTitle)

    // NOTE(sen) Line
    let yLine = document.createElementNS(XMLNS, "line")
    yLine.setAttributeNS(null, "x1", sizes.axisPadLeft)
    yLine.setAttributeNS(null, "x2", sizes.axisPadLeft)
    yLine.setAttributeNS(null, "y1", sizes.plotHeight - sizes.axisPadBottom)
    yLine.setAttributeNS(null, "y2", sizes.axisPadTop)
    yLine.setAttributeNS(null, "stroke", colors.axis)
    titreAxis.appendChild(yLine)
    let yLine2 = document.createElementNS(XMLNS, "line")
    yLine2.setAttributeNS(null, "x1", plotWidth)
    yLine2.setAttributeNS(null, "x2", plotWidth)
    yLine2.setAttributeNS(null, "y1", sizes.plotHeight - sizes.axisPadBottom)
    yLine2.setAttributeNS(null, "y2", sizes.axisPadTop)
    yLine2.setAttributeNS(null, "stroke", colors.axis)
    titreAxis.appendChild(yLine2)

    // NOTE(sen) Ticks and numbers
    let yTicks = [5, 10, 20, 40, 80, 160, 320, 640, 1280, 2560, 5120, 10240]
    for (let yTick of yTicks) {
      let yCoord = scaleTitre(yTick)

      let tick = document.createElementNS(XMLNS, "line")
      tick.setAttributeNS(null, "x1", sizes.axisPadLeft - sizes.tickLength - 1)
      tick.setAttributeNS(null, "x2", sizes.axisPadLeft - 1)
      tick.setAttributeNS(null, "y1", yCoord)
      tick.setAttributeNS(null, "y2", yCoord)
      tick.setAttributeNS(null, "stroke", colors.axis)
      titreAxis.appendChild(tick)

      let gridline = document.createElementNS(XMLNS, "line")
      gridline.setAttributeNS(null, "x1", sizes.axisPadLeft + 1)
      gridline.setAttributeNS(null, "x2", plotWidth)
      gridline.setAttributeNS(null, "y1", yCoord)
      gridline.setAttributeNS(null, "y2", yCoord)
      gridline.setAttributeNS(null, "stroke", colors.grid)
      titreAxis.appendChild(gridline)

      let number = document.createElementNS(XMLNS, "text")
      number.setAttributeNS(
        null,
        "x",
        sizes.axisPadLeft - sizes.tickLength * 1.5
      )
      number.setAttributeNS(null, "y", yCoord)
      number.setAttributeNS(null, "fill", colors.text)
      number.setAttributeNS(null, "dominant-baseline", "middle")
      number.setAttributeNS(null, "text-anchor", "end")
      number.innerHTML = yTick.toFixed()
      titreAxis.appendChild(number)
    }

    return titreAxis
  }

  const createXAxisBottomLine = (plotWidth, sizes, colors) => {
    let xLine = document.createElementNS(XMLNS, "line")
    xLine.setAttributeNS(null, "x1", sizes.axisPadLeft)
    xLine.setAttributeNS(null, "x2", plotWidth)
    xLine.setAttributeNS(null, "y1", sizes.plotHeight - sizes.axisPadBottom)
    xLine.setAttributeNS(null, "y2", sizes.plotHeight - sizes.axisPadBottom)
    xLine.setAttributeNS(null, "stroke", colors.axis)
    return xLine
  }

  const createXAxisTopLine = (plotWidth, sizes, colors) => {
    let xLine2 = document.createElementNS(XMLNS, "line")
    xLine2.setAttributeNS(null, "x1", sizes.axisPadLeft)
    xLine2.setAttributeNS(null, "x2", plotWidth)
    xLine2.setAttributeNS(null, "y1", sizes.axisPadTop)
    xLine2.setAttributeNS(null, "y2", sizes.axisPadTop)
    xLine2.setAttributeNS(null, "stroke", colors.axis)
    return xLine2
  }

  const createXTick = (xCoord, sizes, colors) => {
    let tick = document.createElementNS(XMLNS, "line")
    tick.setAttributeNS(null, "x1", xCoord)
    tick.setAttributeNS(null, "x2", xCoord)
    tick.setAttributeNS(null, "y1", sizes.plotHeight - sizes.axisPadBottom + 1)
    tick.setAttributeNS(
      null,
      "y2",
      sizes.plotHeight - sizes.axisPadBottom + 1 + sizes.tickLength
    )
    tick.setAttributeNS(null, "stroke", colors.axis)
    return tick
  }

  const createXLabel = (label, angle, textAnchor, xCoord, sizes, colors) => {
    let yCoord = sizes.plotHeight - sizes.axisPadBottom + sizes.tickLength * 2

    let element = document.createElementNS(XMLNS, "text")
    element.setAttributeNS(null, "x", 0)
    element.setAttributeNS(null, "y", 0)
    element.setAttributeNS(null, "fill", colors.text)
    element.setAttributeNS(null, "dominant-baseline", "hanging")
    element.setAttributeNS(null, "text-anchor", textAnchor)
    element.setAttributeNS(null, "text-wrap", "wrap")
    element.setAttributeNS(
      null,
      "transform",
      `translate(${xCoord}, ${yCoord}) rotate(${angle})`
    )
    element.innerHTML = label
    return element
  }

  const createDashedHLine = (yCoord, plotWidth, sizes, color) => {
    let el = document.createElementNS(XMLNS, "line")
    el.setAttributeNS(null, "x1", sizes.axisPadLeft)
    el.setAttributeNS(null, "x2", plotWidth)
    el.setAttributeNS(null, "y1", yCoord)
    el.setAttributeNS(null, "y2", yCoord)
    el.setAttributeNS(null, "stroke", color)
    el.setAttributeNS(null, "stroke-dasharray", "5,5")
    return el
  }

  const createVLine = (xCoord, col, sizes) => {
    let el = document.createElementNS(XMLNS, "line")
    el.setAttributeNS(null, "x1", xCoord)
    el.setAttributeNS(null, "x2", xCoord)
    el.setAttributeNS(null, "y1", sizes.axisPadTop)
    el.setAttributeNS(null, "y2", sizes.plotHeight - sizes.axisPadBottom)
    el.setAttributeNS(null, "stroke", col)
    return el
  }

  const createPoint = (xCoord, yCoord, col) => {
    let point = document.createElementNS(XMLNS, "circle")
    point.setAttributeNS(null, "cx", xCoord)
    point.setAttributeNS(null, "cy", yCoord)
    point.setAttributeNS(null, "r", "2")
    point.setAttributeNS(null, "fill", col)
    return point
  }

  const createFacetLabel = (xCoord, col, label, sizes) => {
    let el = document.createElementNS(XMLNS, "text")
    el.setAttributeNS(null, "x", xCoord)
    el.setAttributeNS(null, "y", sizes.axisPadTop - sizes.tickLength)
    el.setAttributeNS(null, "fill", col)
    el.setAttributeNS(null, "text-anchor", "middle")
    el.innerHTML = label
    return el
  }

  const createLine = (x1, x2, y1, y2, col) => {
    let line = document.createElementNS(XMLNS, "line")
    line.setAttributeNS(null, "x1", x1)
    line.setAttributeNS(null, "x2", x2)
    line.setAttributeNS(null, "y1", y1)
    line.setAttributeNS(null, "y2", y2)
    line.setAttributeNS(null, "stroke", col)
    return line
  }

  const createCount = (count, xCoord, yCoord, col) => {
    let el = document.createElementNS(XMLNS, "text")
    el.innerHTML = count
    el.setAttributeNS(null, "x", xCoord)
    el.setAttributeNS(null, "y", yCoord)
    el.setAttributeNS(null, "fill", col)
    el.setAttributeNS(null, "text-anchor", "middle")
    el.setAttributeNS(null, "dominant-baseline", "hanging")
    return el
  }

  const calcBoxplotStats = (arr) => {
    let arrSortedAsc = arrAsc(arr)
    let stats = {}

    stats.median = arrSortedAscQuantile(arrSortedAsc, 0.5)
    stats.q25 = arrSortedAscQuantile(arrSortedAsc, 0.25)
    stats.q75 = arrSortedAscQuantile(arrSortedAsc, 0.75)
    stats.max = arrSortedAscMax(arrSortedAsc)
    stats.min = arrSortedAscMin(arrSortedAsc)
    stats.iqr = stats.q75 - stats.q25
    stats.iqr15 = 1.5 * stats.iqr
    let epsilon = 0.00001
    stats.top = arrSortedAscMax(
      arrSortedAsc.filter(
        (val) =>
          val <= stats.q75 + stats.iqr15 + epsilon &&
          val <= stats.q75 + stats.iqr15 - epsilon
      )
    )
    stats.bottom = arrSortedAscMin(
      arrSortedAsc.filter(
        (val) =>
          val >= stats.q25 - stats.iqr15 + epsilon &&
          val >= stats.q25 - stats.iqr15 - epsilon
      )
    )

    return stats
  }

  const calcMeanStats = (arr) => {
    let stats = {}
    stats.mean = arrMean(arr)
    stats.sd = arrSd(arr)
    stats.se = stats.sd / Math.sqrt(arr.length)
    let errorMargin = 1.96 * stats.se
    stats.low = stats.mean - errorMargin
    stats.high = stats.mean + errorMargin
    return stats
  }

  const createErrorBar = (low, mid, high, xCoord, col) => {
    let el = document.createElementNS(XMLNS, "g")
    el.setAttributeNS(null, "fill", col)
    el.setAttributeNS(null, "stroke", col)

    let point = document.createElementNS(XMLNS, "circle")
    point.setAttributeNS(null, "cx", xCoord)
    point.setAttributeNS(null, "cy", mid)
    point.setAttributeNS(null, "r", 5)

    let line = document.createElementNS(XMLNS, "line")
    line.setAttributeNS(null, "y1", low)
    line.setAttributeNS(null, "y2", high)
    line.setAttributeNS(null, "x1", xCoord)
    line.setAttributeNS(null, "x2", xCoord)
    line.setAttributeNS(null, "stroke-width", 3)

    el.appendChild(point)
    el.appendChild(line)

    return el
  }

  const createBoxplotElement = (
    whiskerDown,
    boxDown,
    boxMid,
    boxUp,
    whiskerUp,
    boxWidth,
    xCoord,
    col
  ) => {
    let boxplot = document.createElementNS(XMLNS, "g")
    boxplot.setAttributeNS(null, "stroke", col)

    const isGood = (n) => n !== null && n !== undefined && !isNaN(n)

    const drawBoxplotHline = (yCoord, thickness) => {
      let line = document.createElementNS(XMLNS, "line")

      if (isGood(xCoord) && isGood(yCoord) && isGood(boxWidth)) {
        line.setAttributeNS(null, "x1", xCoord - boxWidth / 2)
        line.setAttributeNS(null, "x2", xCoord + boxWidth / 2)
        line.setAttributeNS(null, "y1", yCoord)
        line.setAttributeNS(null, "y2", yCoord)
        line.setAttributeNS(null, "stroke-width", thickness)
      }

      boxplot.appendChild(line)
    }

    drawBoxplotHline(boxMid, 4)
    drawBoxplotHline(boxUp, 1)
    drawBoxplotHline(boxDown, 1)

    const drawBoxplotVline = (xCoord) => {
      let line = document.createElementNS(XMLNS, "line")
      if (isGood(xCoord) && isGood(boxUp) && isGood(boxDown)) {
        line.setAttributeNS(null, "x1", xCoord)
        line.setAttributeNS(null, "x2", xCoord)
        line.setAttributeNS(null, "y1", boxUp)
        line.setAttributeNS(null, "y2", boxDown)
      }
      boxplot.appendChild(line)
    }

    drawBoxplotVline(xCoord - boxWidth / 2)
    drawBoxplotVline(xCoord + boxWidth / 2)

    const drawBoxplotWhisker = (start, end) => {
      let line = document.createElementNS(XMLNS, "line")
      if (isGood(xCoord) && isGood(start) && isGood(end)) {
        line.setAttributeNS(null, "x1", xCoord)
        line.setAttributeNS(null, "x2", xCoord)
        line.setAttributeNS(null, "y1", start)
        line.setAttributeNS(null, "y2", end)
      }
      boxplot.appendChild(line)
    }

    drawBoxplotWhisker(boxUp, whiskerUp)
    drawBoxplotWhisker(boxDown, whiskerDown)

    return boxplot
  }

  const createSvgElement = () => {
    let plotSvg = document.createElementNS(XMLNS, "svg")
    plotSvg.style.flexShrink = "0"
    plotSvg.style.display = "block"
    return plotSvg
  }

  const setPlotSvgSize = (svg, width, height) => {
    svg.setAttributeNS(null, "viewBox", "0 0 " + width + " " + height)
    svg.setAttributeNS(null, "width", width)
    svg.setAttributeNS(null, "height", height)
  }

  const createScaleLogtitre = (sizes) => {
    return (val) =>
      scale(
        val,
        Math.log(5),
        Math.log(10240),
        sizes.plotHeight - sizes.dataPadY - sizes.axisPadBottom,
        sizes.dataPadY + sizes.axisPadTop
      )
  }

  const createTitrePlotSvg = (
    data,
    vaccineStrains,
    opacities,
    colors,
    sizes
  ) => {
    let plotSvg = createSvgElement()

    if (data !== null && data !== undefined && data.length > 0) {
      //
      // SECTION Scales
      //

      // NOTE(sen) Y-Axis
      let scaleLogtitre = createScaleLogtitre(sizes)
      let scaleTitre = (val) => scaleLogtitre(Math.log(val))

      // NOTE(sen) X-Axis
      let virusClades = {}
      for (row of data) {
        if (virusClades[row.virus] === undefined) {
          virusClades[row.virus] = row.clade
        }
      }

      let labs = arrUnique(data.map((row) => row.testing_lab)).sort(stringSort)
      let labViruses = []
      let labVirusCounts = []
      for (let lab of labs) {
        let labData = data.filter((row) => row.testing_lab == lab)
        let viruses = arrUnique(labData.map((row) => row.virus)).sort(
          (v1, v2) => {
            let result = 0
            let yearPat = /(\d{4})e?$/
            let year1 = yearPat.exec(v1)[1]
            let year2 = yearPat.exec(v2)[1]
            if (year1 !== undefined && year2 !== undefined) {
              result = year1 - year2
            }

            if (result === 0) {
              let clade1 = virusClades[v1]
              let clade2 = virusClades[v2]
              if (clade1 > clade2) {
                result = 1
              } else {
                result = -1
              }
            }

            if (result === 0) {
              if (v1 > v2) {
                result = 1
              } else {
                result = -1
              }
            }
            return result
          }
        )
        labViruses.push(viruses)
        labVirusCounts.push(viruses.length)
      }
      let labVirusCumCounts = arrCumSum(labVirusCounts)

      let plotWidth =
        sizes.dataPadX +
        sizes.axisPadLeft +
        sizes.widthPerElement * labVirusCumCounts[labVirusCumCounts.length - 1]

      const scaleLabIndexVirusIndex = (labIndex, virusIndex) => {
        let virusCount = labVirusCounts[labIndex]
        let virusCumCount = labVirusCumCounts[labIndex]
        let virusCountOffset = virusCumCount - virusCount
        let realIndex = virusIndex + virusCountOffset
        let result = scale(
          realIndex,
          0,
          labVirusCumCounts[labVirusCumCounts.length - 1] - 1,
          sizes.axisPadLeft + sizes.dataPadX,
          plotWidth - sizes.dataPadX
        )
        return result
      }

      setPlotSvgSize(plotSvg, plotWidth, sizes.plotHeight)

      //
      // SECTION Y-Axis
      //

      let yAxis = createTitreAxisElement(
        colors,
        plotWidth,
        sizes,
        scaleTitre,
        "Titre"
      )
      plotSvg.appendChild(yAxis)

      //
      // SECTION X-axis
      //

      // NOTE(sen) Line
      plotSvg.appendChild(createXAxisBottomLine(plotWidth, sizes, colors))
      plotSvg.appendChild(createXAxisTopLine(plotWidth, sizes, colors))

      // NOTE(sen) Ticks and labels
      for (let [labIndex, virusNames] of labViruses.entries()) {
        for (let [virusIndex, virusName] of virusNames.entries()) {
          let xCoord = scaleLabIndexVirusIndex(labIndex, virusIndex)

          plotSvg.appendChild(createXTick(xCoord, sizes, colors))

          plotSvg.appendChild(
            createXLabel(virusName, -45, "end", xCoord, sizes, colors)
          )

          let cladeName = virusClades[virusName]
          let cladeFreq = Math.round(state.cladeFreqs[cladeName] * 100)
          let cladeLabel = createXLabel(
            cladeName + " (" + cladeFreq + "%)",
            -45,
            "end",
            xCoord + sizes.svgTextLineHeightGuess,
            sizes,
            colors
          )

          plotSvg.appendChild(cladeLabel)

          state.cladeFreqElements[cladeName].push(cladeLabel)
        }
      }

      //
      // SECTION Main plot
      //

      // NOTE(sen) Line at 40
      let line40 = createDashedHLine(
        scaleTitre(40),
        plotWidth,
        sizes,
        colors.thresholdLine
      )
      plotSvg.appendChild(line40)
      opacities.line40.titrePlotElements.push(line40)

      // NOTE(sen) The rest of the plot
      for (let [labIndex, virusNames] of labViruses.entries()) {
        let labData = data.filter((row) => row.testing_lab == labs[labIndex])
        let serumIds = arrUnique(labData.map((row) => row.serum_id))

        // NOTE(sen) Lab marker line
        let labFirstX = scaleLabIndexVirusIndex(labIndex, 0)
        let labLastX = scaleLabIndexVirusIndex(
          labIndex,
          labVirusCounts[labIndex] - 1
        )
        if (labIndex < labViruses.length - 1) {
          let markerLineX = labLastX + sizes.widthPerElement / 2
          let markerLine = createVLine(markerLineX, colors.axis, sizes)
          plotSvg.appendChild(markerLine)
        }

        // NOTE(sen) Lab marker text
        let markerTextX = (labLastX + labFirstX) / 2
        let markerText = createFacetLabel(
          markerTextX,
          colors.text,
          labs[labIndex],
          sizes
        )
        plotSvg.appendChild(markerText)

        for (let [virusIndex, virusName] of virusNames.entries()) {
          let virusData = labData.filter((row) => row.virus == virusName)
          let virusDataPrevax = virusData.filter(
            (row) => row.timepoint === "Pre-vax"
          )
          let virusDataPostvax = virusData.filter(
            (row) => row.timepoint === "Post-vax"
          )

          let preVaxPoints = 0
          let postVaxPoints = 0

          let thisPreVaxCol = colors.preVax
          let thisPostVaxCol = colors.postVax
          if (vaccineStrains.includes(virusName)) {
            thisPreVaxCol = colors.vaccinePreVax
            thisPostVaxCol = colors.vaccinePostVax
          }

          for (let serumId of serumIds) {
            let preVaxData = virusDataPrevax.filter(
              (row) => row.serum_id == serumId
            )
            let postVaxData = virusDataPostvax.filter(
              (row) => row.serum_id == serumId
            )

            const drawPoint = (titre, timepoint) => {
              let coords = null

              if (titre) {
                let yCoord = scaleLogtitre(
                  Math.log(titre) + Math.random() * 0.1
                )
                let xCoord =
                  scaleLabIndexVirusIndex(
                    labIndex,
                    virusIndex + (Math.random() - 0.5) * 0.05
                  ) -
                  sizes.prePostDistance / 2

                let col = thisPreVaxCol
                if (timepoint === "Post-vax") {
                  xCoord += sizes.prePostDistance
                  col = thisPostVaxCol
                  postVaxPoints += 1
                } else {
                  preVaxPoints += 1
                }

                let point = createPoint(
                  xCoord,
                  yCoord,
                  col + colChannel255ToString(opacities.points.value)
                )
                plotSvg.appendChild(point)
                opacities.points.titrePlotElements.push(point)
                coords = { x: xCoord, y: yCoord }
              }

              return coords
            }

            let p1 = null
            if (preVaxData.length == 1) {
              p1 = drawPoint(preVaxData[0].titre, "Pre-vax")
            }
            let p2 = null
            if (postVaxData.length == 1) {
              p2 = drawPoint(postVaxData[0].titre, "Post-vax")
            }

            // NOTE(sen) Line
            if (p1 != null && p2 != null) {
              let line = createLine(
                p1.x,
                p2.x,
                p1.y,
                p2.y,
                thisPreVaxCol + colChannel255ToString(opacities.lines.value)
              )
              plotSvg.appendChild(line)
              opacities.lines.titrePlotElements.push(line)
            }
          }

          // NOTE(sen) Point counts and boxplots
          for (let timepoint of ["Pre-vax", "Post-vax"]) {
            // NOTE(sen) Counts
            let col = thisPreVaxCol
            let xCoord =
              scaleLabIndexVirusIndex(labIndex, virusIndex) -
              sizes.prePostDistance / 2
            let countValue = preVaxPoints
            let titres = virusDataPrevax
            if (timepoint == "Post-vax") {
              xCoord += sizes.prePostDistance
              col = thisPostVaxCol
              countValue = postVaxPoints
              titres = virusDataPostvax
            }

            let yCoord = scaleTitre(10240)
            let count = createCount(
              countValue,
              xCoord,
              yCoord,
              col + colChannel255ToString(opacities.counts.value)
            )
            plotSvg.appendChild(count)
            opacities.counts.titrePlotElements.push(count)

            // NOTE(sen) Boxplots
            titres = titres
              .filter((row) => !isNaN(row.titre))
              .map((row) => Math.log(row.titre))

            let boxplotStats = calcBoxplotStats(titres)

            let boxplot = createBoxplotElement(
              scaleLogtitre(boxplotStats.bottom),
              scaleLogtitre(boxplotStats.q25),
              scaleLogtitre(boxplotStats.median),
              scaleLogtitre(boxplotStats.q75),
              scaleLogtitre(boxplotStats.top),
              sizes.boxPlotWidth,
              xCoord,
              col + colChannel255ToString(opacities.boxplots.value)
            )

            plotSvg.appendChild(boxplot)
            opacities.boxplots.titrePlotElements.push(boxplot)

            // NOTE(sen) GMTs
            let gmtStats = calcMeanStats(titres)
            let gmtErrorBar = createErrorBar(
              scaleLogtitre(gmtStats.low),
              scaleLogtitre(gmtStats.mean),
              scaleLogtitre(gmtStats.high),
              xCoord,
              colChangeSaturation(
                col + colChannel255ToString(opacities.means.value),
                2
              )
            )

            plotSvg.appendChild(gmtErrorBar)
            opacities.means.titrePlotElements.push(gmtErrorBar)
          } // NOTE(sen) for (timepoint)
        } // NOTE(sen) for (virus)
      } // NOTE(sen) for (lab)
    }

    return plotSvg
  }

  const createTitreCladeAveragePlotSvg = (
    data,
    vaccineClades,
    opacities,
    colors,
    sizes
  ) => {
    let plotSvg = createSvgElement()

    if (data !== null && data !== undefined && data.length > 0) {
      //
      // SECTION Scales
      //

      // NOTE(sen) Y-Axis
      let scaleLogtitre = createScaleLogtitre(sizes)
      let scaleTitre = (val) => scaleLogtitre(Math.log(val))

      // NOTE(sen) X-Axis

      let labs = arrUnique(data.map((row) => row.testing_lab)).sort(stringSort)

      let labClades = []
      let labCladeCounts = []
      for (let lab of labs) {
        let labData = data.filter((row) => row.testing_lab == lab)
        let clades = arrUnique(labData.map((row) => row.clade)).sort(stringSort)
        labClades.push(clades)
        labCladeCounts.push(clades.length)
      }
      let labCladeCumCounts = arrCumSum(labCladeCounts)

      let plotWidth =
        sizes.dataPadX +
        sizes.axisPadLeft +
        sizes.widthPerElement * labCladeCumCounts[labCladeCumCounts.length - 1]

      const scaleLabIndexCladeIndex = (labIndex, cladeIndex) => {
        let cladeCount = labCladeCounts[labIndex]
        let cladeCumCount = labCladeCumCounts[labIndex]
        let cladeCountOffset = cladeCumCount - cladeCount
        let realIndex = cladeIndex + cladeCountOffset
        let result = scale(
          realIndex,
          0,
          labCladeCumCounts[labCladeCumCounts.length - 1] - 1,
          sizes.axisPadLeft + sizes.dataPadX,
          plotWidth - sizes.dataPadX
        )
        return result
      }

      setPlotSvgSize(plotSvg, plotWidth, sizes.plotHeight)

      //
      // SECTION Y-Axis
      //

      let yAxis = createTitreAxisElement(
        colors,
        plotWidth,
        sizes,
        scaleTitre,
        "Clade average titre"
      )
      plotSvg.appendChild(yAxis)

      //
      // SECTION X-axis
      //

      // NOTE(sen) Line
      plotSvg.appendChild(createXAxisBottomLine(plotWidth, sizes, colors))
      plotSvg.appendChild(createXAxisTopLine(plotWidth, sizes, colors))

      // NOTE(sen) Ticks and labels
      for (let [labIndex, cladeNames] of labClades.entries()) {
        for (let [cladeIndex, cladeName] of cladeNames.entries()) {
          let xCoord = scaleLabIndexCladeIndex(labIndex, cladeIndex)

          plotSvg.appendChild(createXTick(xCoord, sizes, colors))

          let cladeFreq = Math.round(state.cladeFreqs[cladeName] * 100)
          let label = createXLabel(
            cladeName + " (" + cladeFreq + "%)",
            -30,
            "end",
            xCoord,
            sizes,
            colors
          )

          plotSvg.appendChild(label)
          state.cladeFreqElements[cladeName].push(label)
        }
      }

      //
      // SECTION Main plot
      //

      // NOTE(sen) Line at 40
      let line40 = createDashedHLine(
        scaleTitre(40),
        plotWidth,
        sizes,
        colors.thresholdLine
      )
      plotSvg.appendChild(line40)
      opacities.line40.titreCladeAveragePlotElements.push(line40)

      // NOTE(sen) The rest of the plot
      for (let [labIndex, cladeNames] of labClades.entries()) {
        let labData = data.filter((row) => row.testing_lab == labs[labIndex])
        let serumIds = arrUnique(labData.map((row) => row.serum_id))

        // NOTE(sen) Lab marker line
        let labFirstX = scaleLabIndexCladeIndex(labIndex, 0)
        let labLastX = scaleLabIndexCladeIndex(
          labIndex,
          labCladeCounts[labIndex] - 1
        )
        if (labIndex < labClades.length - 1) {
          let markerLineX = labLastX + sizes.widthPerElement / 2
          let markerLine = createVLine(markerLineX, colors.axis, sizes)
          plotSvg.appendChild(markerLine)
        }

        // NOTE(sen) Lab marker text
        let markerTextX = (labLastX + labFirstX) / 2
        let markerText = createFacetLabel(
          markerTextX,
          colors.text,
          labs[labIndex],
          sizes
        )
        plotSvg.appendChild(markerText)

        for (let [cladeIndex, cladeName] of cladeNames.entries()) {
          let cladeData = labData.filter((row) => row.clade == cladeName)
          let cladeDataPrevax = cladeData.filter(
            (row) => row.timepoint === "Pre-vax"
          )
          let cladeDataPostvax = cladeData.filter(
            (row) => row.timepoint === "Post-vax"
          )

          let preVaxPoints = 0
          let postVaxPoints = 0

          let thisPreVaxCol = colors.preVax
          let thisPostVaxCol = colors.postVax
          if (vaccineClades.includes(cladeName)) {
            thisPreVaxCol = colors.vaccinePreVax
            thisPostVaxCol = colors.vaccinePostVax
          }

          for (let serumId of serumIds) {
            let preVaxData = cladeDataPrevax.filter(
              (row) => row.serum_id == serumId
            )
            let postVaxData = cladeDataPostvax.filter(
              (row) => row.serum_id == serumId
            )

            const drawPoint = (titre, timepoint) => {
              let coords = null

              if (titre) {
                let yCoord = scaleLogtitre(Math.log(titre))
                let xCoord =
                  scaleLabIndexCladeIndex(
                    labIndex,
                    cladeIndex + (Math.random() - 0.5) * 0.05
                  ) -
                  sizes.prePostDistance / 2

                let col = thisPreVaxCol
                if (timepoint === "Post-vax") {
                  xCoord += sizes.prePostDistance
                  col = thisPostVaxCol
                  postVaxPoints += 1
                } else {
                  preVaxPoints += 1
                }

                let point = createPoint(
                  xCoord,
                  yCoord,
                  col + colChannel255ToString(opacities.points.value)
                )
                plotSvg.appendChild(point)
                opacities.points.titreCladeAveragePlotElements.push(point)
                coords = { x: xCoord, y: yCoord }
              }

              return coords
            }

            let p1 = null
            if (preVaxData.length == 1) {
              p1 = drawPoint(preVaxData[0].titreCladeAverage, "Pre-vax")
            }
            let p2 = null
            if (postVaxData.length == 1) {
              p2 = drawPoint(postVaxData[0].titreCladeAverage, "Post-vax")
            }

            // NOTE(sen) Line
            if (p1 != null && p2 != null) {
              let line = createLine(
                p1.x,
                p2.x,
                p1.y,
                p2.y,
                thisPreVaxCol + colChannel255ToString(opacities.lines.value)
              )
              plotSvg.appendChild(line)
              opacities.lines.titreCladeAveragePlotElements.push(line)
            }
          } // NOTE(sen) for serum id

          // NOTE(sen) Point counts and boxplots
          for (let timepoint of ["Pre-vax", "Post-vax"]) {
            // NOTE(sen) Counts
            let col = thisPreVaxCol
            let xCoord =
              scaleLabIndexCladeIndex(labIndex, cladeIndex) -
              sizes.prePostDistance / 2
            let countValue = preVaxPoints
            let titres = cladeDataPrevax
            if (timepoint == "Post-vax") {
              xCoord += sizes.prePostDistance
              col = thisPostVaxCol
              countValue = postVaxPoints
              titres = cladeDataPostvax
            }

            let yCoord = scaleTitre(10240)
            let count = createCount(
              countValue,
              xCoord,
              yCoord,
              col + colChannel255ToString(opacities.counts.value)
            )
            plotSvg.appendChild(count)
            opacities.counts.titreCladeAveragePlotElements.push(count)

            // NOTE(sen) Boxplots
            titres = titres
              .filter((row) => !isNaN(row.titreCladeAverage))
              .map((row) => Math.log(row.titreCladeAverage))

            let boxplotStats = calcBoxplotStats(titres)

            let boxplot = createBoxplotElement(
              scaleLogtitre(boxplotStats.bottom),
              scaleLogtitre(boxplotStats.q25),
              scaleLogtitre(boxplotStats.median),
              scaleLogtitre(boxplotStats.q75),
              scaleLogtitre(boxplotStats.top),
              sizes.boxPlotWidth,
              xCoord,
              col + colChannel255ToString(opacities.boxplots.value)
            )

            plotSvg.appendChild(boxplot)
            opacities.boxplots.titreCladeAveragePlotElements.push(boxplot)

            // NOTE(sen) GMTs
            let gmtStats = calcMeanStats(titres)
            let gmtErrorBar = createErrorBar(
              scaleLogtitre(gmtStats.low),
              scaleLogtitre(gmtStats.mean),
              scaleLogtitre(gmtStats.high),
              xCoord,
              colChangeSaturation(
                col + colChannel255ToString(opacities.means.value),
                2
              )
            )

            plotSvg.appendChild(gmtErrorBar)
            opacities.means.titreCladeAveragePlotElements.push(gmtErrorBar)
          } // NOTE(sen) for timepoint
        } // NOTE(sen) for clade
      } // NOTE(sen) for lab
    } // NOTE(sen) if data

    return plotSvg
  }

  const createTitreCirculatingAveragePlotSvg = (
    data,
    opacities,
    colors,
    sizes
  ) => {
    let plotSvg = createSvgElement()

    if (data !== null && data !== undefined && data.length > 0) {
      //
      // SECTION Scales
      //

      // NOTE(sen) Y-Axis
      let scaleLogtitre = createScaleLogtitre(sizes)
      let scaleTitre = (val) => scaleLogtitre(Math.log(val))

      // NOTE(sen) X-Axis
      let labs = arrUnique(data.map((row) => row.testing_lab)).sort(stringSort)

      let plotWidth = sizes.widthPerElement * labs.length + sizes.axisPadLeft

      const scaleLabIndex = (labIndex) =>
        scale(
          labIndex,
          0,
          labs.length - 1,
          sizes.axisPadLeft + sizes.dataPadX,
          plotWidth - sizes.dataPadX
        )

      setPlotSvgSize(plotSvg, plotWidth, sizes.plotHeight)

      //
      // SECTION Y-Axis
      //

      let yAxis = createTitreAxisElement(
        colors,
        plotWidth,
        sizes,
        scaleTitre,
        "Circulating average titre"
      )
      plotSvg.appendChild(yAxis)

      //
      // SECTION X-axis
      //

      // NOTE(sen) Line
      plotSvg.appendChild(createXAxisBottomLine(plotWidth, sizes, colors))
      plotSvg.appendChild(createXAxisTopLine(plotWidth, sizes, colors))

      // NOTE(sen) Ticks and labels
      for (let [labIndex, labName] of labs.entries()) {
        let xCoord = scaleLabIndex(labIndex)
        plotSvg.appendChild(createXTick(xCoord, sizes, colors))
        plotSvg.appendChild(
          createXLabel(labName, 0, "middle", xCoord, sizes, colors)
        )
      }

      //
      // SECTION Main plot
      //

      // NOTE(sen) Line at 40
      let line40 = createDashedHLine(
        scaleTitre(40),
        plotWidth,
        sizes,
        colors.thresholdLine
      )
      plotSvg.appendChild(line40)
      opacities.line40.titreCirculatingAveragePlotElements.push(line40)

      // NOTE(sen) The rest of the plot
      for (let [labIndex, labName] of labs.entries()) {
        let labData = data.filter((row) => row.testing_lab == labName)
        let serumIds = arrUnique(labData.map((row) => row.serum_id))

        let labDataPrevax = labData.filter((row) => row.timepoint === "Pre-vax")
        let labDataPostvax = labData.filter(
          (row) => row.timepoint === "Post-vax"
        )

        let preVaxPoints = 0
        let postVaxPoints = 0

        for (let serumId of serumIds) {
          let preVaxData = labDataPrevax.filter(
            (row) => row.serum_id == serumId
          )
          let postVaxData = labDataPostvax.filter(
            (row) => row.serum_id == serumId
          )

          const drawPoint = (titre, timepoint) => {
            let coords = null

            if (titre) {
              let yCoord = scaleLogtitre(Math.log(titre))
              let xCoord = scaleLabIndex(labIndex) - sizes.prePostDistance / 2

              let col = colors.preVax
              if (timepoint === "Post-vax") {
                xCoord += sizes.prePostDistance
                col = colors.postVax
                postVaxPoints += 1
              } else {
                preVaxPoints += 1
              }

              let point = createPoint(
                xCoord,
                yCoord,
                col + colChannel255ToString(opacities.points.value)
              )
              plotSvg.appendChild(point)
              opacities.points.titreCirculatingAveragePlotElements.push(point)
              coords = { x: xCoord, y: yCoord }
            }

            return coords
          }

          let p1 = null
          if (preVaxData.length == 1) {
            p1 = drawPoint(preVaxData[0].titreCirculatingAverage, "Pre-vax")
          }
          let p2 = null
          if (postVaxData.length == 1) {
            p2 = drawPoint(postVaxData[0].titreCirculatingAverage, "Post-vax")
          }

          // NOTE(sen) Line
          if (p1 != null && p2 != null) {
            let line = createLine(
              p1.x,
              p2.x,
              p1.y,
              p2.y,
              colors.preVax + colChannel255ToString(opacities.lines.value)
            )
            plotSvg.appendChild(line)
            opacities.lines.titreCirculatingAveragePlotElements.push(line)
          }
        } // NOTE(sen) for serum id

        // NOTE(sen) Point counts and boxplots
        for (let timepoint of ["Pre-vax", "Post-vax"]) {
          // NOTE(sen) Counts

          let col = colors.preVax
          let xCoord = scaleLabIndex(labIndex) - sizes.prePostDistance / 2
          let countValue = preVaxPoints
          let titres = labDataPrevax
          if (timepoint == "Post-vax") {
            xCoord += sizes.prePostDistance
            col = colors.postVax
            countValue = postVaxPoints
            titres = labDataPostvax
          }

          let yCoord = scaleTitre(10240)
          let count = createCount(
            countValue,
            xCoord,
            yCoord,
            col + colChannel255ToString(opacities.counts.value)
          )
          plotSvg.appendChild(count)
          opacities.counts.titreCirculatingAveragePlotElements.push(count)

          // NOTE(sen) Boxplots
          titres = titres
            .filter((row) => !isNaN(row.titreCirculatingAverage))
            .map((row) => Math.log(row.titreCirculatingAverage))

          let boxplotStats = calcBoxplotStats(titres)

          let boxplot = createBoxplotElement(
            scaleLogtitre(boxplotStats.bottom),
            scaleLogtitre(boxplotStats.q25),
            scaleLogtitre(boxplotStats.median),
            scaleLogtitre(boxplotStats.q75),
            scaleLogtitre(boxplotStats.top),
            sizes.boxPlotWidth,
            xCoord,
            col + colChannel255ToString(opacities.boxplots.value)
          )

          plotSvg.appendChild(boxplot)
          opacities.boxplots.titreCirculatingAveragePlotElements.push(boxplot)

          // NOTE(sen) GMTs
          let gmtStats = calcMeanStats(titres)
          let gmtErrorBar = createErrorBar(
            scaleLogtitre(gmtStats.low),
            scaleLogtitre(gmtStats.mean),
            scaleLogtitre(gmtStats.high),
            xCoord,
            colChangeSaturation(
              col + colChannel255ToString(opacities.means.value),
              2
            )
          )

          plotSvg.appendChild(gmtErrorBar)
          opacities.means.titreCirculatingAveragePlotElements.push(gmtErrorBar)
        } // NOTE(sen) for timepoint
      } // NOTE(sen) for lab
    } // NOTE(sen) if data

    return plotSvg
  }

  let state = {
    data: [],
    dataCladeAverageTitres: [],
    dataCirculatingAverageTitres: [],
    cladeFreqsDefault: {},
    cladeFreqs: {},
    subtypeClades: {},
    filters: {
      subtype: { elements: [], options: [], selected: null },
      serum_source: { elements: [], options: [], selected: null },
      cohort: { elements: [], options: [], selected: null },
    },
    opacities: {
      points: {
        titrePlotElements: [],
        titreCladeAveragePlotElements: [],
        titreCirculatingAveragePlotElements: [],
        value: 255,
        default: 255,
      },
      lines: {
        titrePlotElements: [],
        titreCladeAveragePlotElements: [],
        titreCirculatingAveragePlotElements: [],
        value: 127,
        default: 127,
      },
      boxplots: {
        titrePlotElements: [],
        titreCladeAveragePlotElements: [],
        titreCirculatingAveragePlotElements: [],
        value: 255,
        default: 255,
      },
      counts: {
        titrePlotElements: [],
        titreCladeAveragePlotElements: [],
        titreCirculatingAveragePlotElements: [],
        value: 255,
        default: 255,
      },
      line40: {
        titrePlotElements: [],
        titreCladeAveragePlotElements: [],
        titreCirculatingAveragePlotElements: [],
        value: 255,
        default: 255,
      },
      means: {
        titrePlotElements: [],
        titreCladeAveragePlotElements: [],
        titreCirculatingAveragePlotElements: [],
        value: 255,
        default: 255,
      },
    },
    colors: {
      theme: "dark",
      preVax: "#308A36",
      postVax: "#7FA438",
      vaccinePreVax: "#8E3164",
      vaccinePostVax: "#B0403D",
      text: "var(--color-text)",
      axis: "#aaaaaa",
      thresholdLine: null,
      grid: "#99999944",
    },
    defaultPlotSizes: {
      plotHeight: 600,
      widthPerElement: 100,
      axisPadLeft: 80,
      axisPadBottom: 250,
      axisPadTop: 20,
      dataPadX: 50,
      dataPadY: 10,
      tickLength: 5,
      prePostDistance: 40,
      boxPlotWidth: 15,
      svgTextLineHeightGuess: 20,
    },
    sizes: {
      inputBar: "200px",
    },
    main: document.getElementById("main"),
    inputContainer: null,
    plotContainer: null,
    titrePlotContainer: null,
    titreCladeAveragePlotContainer: null,
    titreCirculatingAveragePlotContainer: null,
    slidersContainer: null,
    subtypeSlidersContainers: {},
    cladeFreqElements: {},
    filtersContainer: null,
    opacitiesContainer: null,
    fileSelectTextElement: null,
    scrollbarStyle: null,
  }
  state.colors.thresholdLine =
    state.colors.axis + colChannel255ToString(state.opacities.line40.value)

  const areAllFiltersSet = () => {
    let allFiltersSet = true
    for (let varName of Object.keys(state.filters)) {
      if (state.filters[varName].selected === null) {
        allFiltersSet = false
        break
      }
    }
    return allFiltersSet
  }

  const updateSliderSubtype = () => {
    for (let [subtype, slidersContainer] of Object.entries(
      state.subtypeSlidersContainers
    )) {
      if (subtype === state.filters.subtype.selected) {
        slidersContainer.style.display = "block"
      } else {
        slidersContainer.style.display = "none"
      }
    }
  }

  const updateFilterColors = () => {
    for (let varName of Object.keys(state.filters)) {
      let otherVarNames = Object.keys(state.filters).filter(
        (key) => key !== varName
      )

      for (let [optionIndex, option] of state.filters[
        varName
      ].options.entries()) {
        let testRows = state.data.filter((row) => {
          let result = row[varName] === option
          if (result) {
            for (let otherVarName of otherVarNames) {
              result =
                row[otherVarName] === state.filters[otherVarName].selected
              if (!result) {
                break
              }
            }
          }
          return result
        })

        let element = state.filters[varName].elements[optionIndex]

        if (testRows.length === 0) {
          element.style.color = "var(--color-error)"
        } else {
          element.style.color = "inherit"
        }
      }
    }
  }

  const findNonEmptyFilterSubset = () => {
    if (!areAllFiltersSet()) {
      let currentSettings = []
      for (let [filterIndex, varName] of Object.keys(state.filters).entries()) {
        currentSettings.push({
          name: varName,
          lastIndex: state.filters[varName].options.length - 1,
          currentIndex: 0,
        })
      }

      let currentFilteredDataRows = 0
      let currentlyIncrementing = currentSettings.length - 1

      while (currentFilteredDataRows === 0) {
        for (let [filterIndex, varName] of Object.keys(
          state.filters
        ).entries()) {
          state.filters[varName].selected =
            state.filters[varName].options[
              currentSettings[filterIndex].currentIndex
            ]
          for (let [optionIndex, optionEl] of state.filters[
            varName
          ].elements.entries()) {
            if (optionIndex === currentSettings[filterIndex].currentIndex) {
              optionEl.style.background = "var(--color-selected)"
            } else {
              optionEl.style.background = "inherit"
            }
          }
        }

        let testRows = state.data.filter((row) => {
          let result = true
          for (let varName of Object.keys(state.filters)) {
            result = row[varName] === state.filters[varName].selected
            if (!result) {
              break
            }
          }
          return result
        })

        currentFilteredDataRows = testRows.length

        if (
          currentSettings[currentlyIncrementing].currentIndex ===
          currentSettings[currentlyIncrementing].lastIndex
        ) {
          currentSettings[currentlyIncrementing].currentIndex = 0

          currentlyIncrementing -= 1
          if (currentlyIncrementing === -1) {
            currentlyIncrementing = currentSettings.length - 1
          }
        }

        if (
          currentSettings[currentlyIncrementing].currentIndex ===
          currentSettings[currentlyIncrementing].lastIndex
        ) {
          break
        } else {
          currentSettings[currentlyIncrementing].currentIndex += 1
        }
      }

      updateSliderSubtype()
      updateFilterColors()
    }
  }

  const createSubsetFilter = () => {
    return (row) => {
      let result = true
      for (let varName of Object.keys(state.filters)) {
        result = row[varName] === state.filters[varName].selected
        if (!result) {
          break
        }
      }
      return result
    }
  }

  const updateTitrePlot = () => {
    if (areAllFiltersSet()) {
      const subsetFilter = createSubsetFilter()

      let dataSubset = state.data.filter(subsetFilter)

      while (state.titrePlotContainer.lastChild) {
        state.titrePlotContainer.removeChild(state.titrePlotContainer.lastChild)
      }

      for (let varName of Object.keys(state.opacities)) {
        state.opacities[varName].titrePlotElements = []
      }

      let plotSvg = createTitrePlotSvg(
        dataSubset,
        [
          "A/Guangdong-Maonan/SWL1536/2019e",
          "A/Hong Kong/2671/2019e",
          "B/Washington/02/2019e",
        ],
        state.opacities,
        state.colors,
        state.defaultPlotSizes
      )

      state.titrePlotContainer.appendChild(plotSvg)
    }
  }

  const updateTitreCladeAveragePlot = () => {
    if (areAllFiltersSet()) {
      const subsetFilter = createSubsetFilter()

      let dataSubsetCladeAverages =
        state.dataCladeAverageTitres.filter(subsetFilter)

      while (state.titreCladeAveragePlotContainer.lastChild) {
        state.titreCladeAveragePlotContainer.removeChild(
          state.titreCladeAveragePlotContainer.lastChild
        )
      }

      for (let varName of Object.keys(state.opacities)) {
        state.opacities[varName].titreCladeAveragePlotElements = []
      }

      let plotCladeAverageTitresSvg = createTitreCladeAveragePlotSvg(
        dataSubsetCladeAverages,
        ["A5a.1", "A1b/137F", "V1A.3"],
        state.opacities,
        state.colors,
        reduceAxisPadBottom(100, state.defaultPlotSizes)
      )

      state.titreCladeAveragePlotContainer.appendChild(
        plotCladeAverageTitresSvg
      )
    }
  }

  const updateTitreCirculatingAveragePlot = () => {
    if (areAllFiltersSet()) {
      const subsetFilter = createSubsetFilter()

      let dataSubsetCirculatingAverages =
        state.dataCirculatingAverageTitres.filter(subsetFilter)

      while (state.titreCirculatingAveragePlotContainer.lastChild) {
        state.titreCirculatingAveragePlotContainer.removeChild(
          state.titreCirculatingAveragePlotContainer.lastChild
        )
      }

      for (let varName of Object.keys(state.opacities)) {
        state.opacities[varName].titreCirculatingAveragePlotElements = []
      }

      let plotCirculatingAverageTitresSvg =
        createTitreCirculatingAveragePlotSvg(
          dataSubsetCirculatingAverages,
          state.opacities,
          state.colors,
          reduceAxisPadBottom(40, state.defaultPlotSizes)
        )

      state.titreCirculatingAveragePlotContainer.appendChild(
        plotCirculatingAverageTitresSvg
      )
    }
  }

  const updateCirculatingAverageData = () => {
    state.dataCirculatingAverageTitres = []
    if (state.dataCladeAverageTitres.length > 0) {
      let groupVars = Object.keys(state.dataCladeAverageTitres[0]).filter(
        (key) =>
          key !== "titreCladeAverage" && key !== "clade" && key !== "clade_freq"
      )
      let groupedData = groupByMultiple(state.dataCladeAverageTitres, groupVars)

      state.dataCirculatingAverageTitres = summariseGrouped(
        groupedData,
        groupVars,
        (data) => {
          let sumLogTitres = 0
          let sumWeights = 0
          for (let row of data) {
            let weight = state.cladeFreqs[row.clade]
            let titre = row.titreCladeAverage
            if (
              !isNaN(weight) &&
              weight !== null &&
              weight !== undefined &&
              titre !== null &&
              titre !== undefined &&
              !isNaN(titre)
            ) {
              sumLogTitres += weight * Math.log(row.titreCladeAverage)
              sumWeights += weight
            }
          }
          let weightedMean = null
          if (sumWeights !== 0) {
            weightedMean = Math.exp(sumLogTitres / sumWeights)
          }
          return { titreCirculatingAverage: weightedMean }
        }
      )
      updateTitreCirculatingAveragePlot()
    }
  }

  const updateData = (contentsString) => {
    if (contentsString.length > 0) {
      // NOTE(sen) Main data
      state.data = parseData(contentsString)

      // NOTE(sen) Clade frequencies
      state.cladeFreqs = {}
      state.cladeFreqsDefault = {}
      for (row of state.data) {
        if (state.cladeFreqs[row.clade] === undefined) {
          state.cladeFreqs[row.clade] = Math.round(row.clade_freq * 100) / 100
          state.cladeFreqsDefault[row.clade] = state.cladeFreqs[row.clade]
        }
      }

      // NOTE(sen) Subtype clades
      state.subtypeClades = {}
      if (state.data.length > 0) {
        let subtypes = arrUnique(state.data.map((row) => row.subtype)).sort(
          desiredOrderSort(["H1", "H3", "BVic"])
        )
        for (let subtype of subtypes) {
          let clades = arrUnique(
            state.data
              .filter((row) => row.subtype === subtype)
              .map((row) => row.clade)
          )
          state.subtypeClades[subtype] = clades.sort(stringSort)
        }
      }

      // NOTE(sen) Populate clade frequency sliders
      while (state.slidersContainer.lastChild) {
        state.slidersContainer.removeChild(state.slidersContainer.lastChild)
      }
      state.subtypeSlidersContainers = {}
      state.cladeFreqElements = {}
      for (let [subtype, clades] of Object.entries(state.subtypeClades)) {
        let subtypeContainer = document.createElement("div")
        subtypeContainer.style.marginBottom = "5px"

        for (let clade of clades) {
          let slider = document.createElement("div")

          let name = document.createElement("div")
          name.innerHTML =
            clade + " (" + Math.round(state.cladeFreqs[clade] * 100) + "%)"
          name.style.textAlign = "center"

          let reset = document.createElement("div")
          reset.innerHTML = ""
          reset.style.cursor = "pointer"
          reset.style.color = "var(--color-border)"

          let top = document.createElement("div")
          top.style.display = "flex"
          top.style.justifyContent = "space-between"

          top.appendChild(name)
          top.appendChild(reset)

          let input = document.createElement("input")
          input.setAttribute("type", "range")
          input.setAttribute("min", "0")
          input.setAttribute("max", "100")
          input.value = state.cladeFreqs[clade] * 100
          input.addEventListener("input", (event) => {
            state.cladeFreqs[clade] = event.target.value / 100
            name.innerHTML = clade + " (" + event.target.value + "%)"
            for (let el of state.cladeFreqElements[clade]) {
              el.innerHTML = clade + " (" + event.target.value + "%)"
            }
            updateCirculatingAverageData()
            if (state.cladeFreqs[clade] === state.cladeFreqsDefault[clade]) {
              reset.style.color = "var(--color-border)"
            } else {
              reset.style.color = "var(--color-text)"
            }
          })

          reset.addEventListener("click", (event) => {
            input.value = state.cladeFreqsDefault[clade] * 100
            input.dispatchEvent(new Event("input"))
          })

          slider.appendChild(top)
          slider.appendChild(input)

          subtypeContainer.appendChild(slider)

          state.cladeFreqElements[clade] = []
        }

        state.slidersContainer.appendChild(subtypeContainer)
        state.subtypeSlidersContainers[subtype] = subtypeContainer
      }

      // NOTE(sen) Work out clade-average titres
      state.dataCladeAverageTitres = []
      if (state.data.length > 0) {
        let groupVars = Object.keys(state.data[0]).filter(
          (key) => key !== "titre" && key !== "virus" && key !== "egg_cell"
        )
        let groupedData = groupByMultiple(
          state.data.filter((row) => row.clade !== "unassigned"),
          groupVars
        )

        state.dataCladeAverageTitres = summariseGrouped(
          groupedData,
          groupVars,
          (data) => {
            let dataSubsetNoEggs = data
            if (dataSubsetNoEggs.length > 1) {
              dataSubsetNoEggs = dataSubsetNoEggs.filter(
                (row) => row.egg_cell === "Cell"
              )
            }
            let logtitres = dataSubsetNoEggs.map((row) => Math.log(row.titre))
            let logmean = arrMean(logtitres)
            return { titreCladeAverage: Math.exp(logmean) }
          }
        )
      }

      // NOTE(sen) Populate filters
      for (let varName of Object.keys(state.filters)) {
        state.filters[varName].selected = null

        state.filters[varName].options = arrUnique(
          state.data.map((row) => row[varName])
        )

        switch (varName) {
          case "cohort": {
            state.filters[varName].options = state.filters[
              varName
            ].options.sort(
              desiredOrderSort([
                "Ped (<3 yr)",
                "Ped (3-8 yr)",
                "Ped (9-17 yr)",
                "Ped (<18 yr)",
                "Adult (18-49 yr)",
                "Adult (50-64 yr)",
                "Adult (18-64 yr)",
                "Elderly (>=65yr)",
              ])
            )
            break
          }
          case "subtype": {
            state.filters[varName].options = state.filters[
              varName
            ].options.sort(desiredOrderSort(["H1", "H3", "BVic"]))
            break
          }
          case "serum_source": {
            state.filters[varName].options = state.filters[
              varName
            ].options.sort((a, b) => (a > b ? 1 : a < b ? -1 : 0))
            break
          }
        }
      }

      // NOTE(sen) Draw the newly populated filters
      state.filtersContainer.innerHTML = ""

      for (let varName of Object.keys(state.filters)) {
        let filterEl = document.createElement("div")

        filterEl.style.display = "flex"
        filterEl.style.flexDirection = "column"
        filterEl.style.marginBottom = "10px"
        filterEl.style.flexGrow = "1"

        state.filters[varName].elements = []

        for (let option of state.filters[varName].options) {
          let optionEl = document.createElement("div")
          optionEl.innerHTML = option

          optionEl.addEventListener("click", (event) => {
            state.filters[varName].selected = option
            for (let otherOption of state.filters[varName].elements) {
              otherOption.style.background = "inherit"
            }
            optionEl.style.background = "var(--color-selected)"
            updateTitrePlot()
            updateTitreCladeAveragePlot()
            updateTitreCirculatingAveragePlot()
            updateFilterColors()
            if (varName === "subtype") {
              updateSliderSubtype()
            }
          })

          optionEl.style.padding = "5px"
          optionEl.style.border = "1px solid var(--color-border)"
          optionEl.style.cursor = "pointer"
          optionEl.style.textAlign = "center"

          if (option === state.filters[varName].selected) {
            optionEl.style.background = "var(--color-selected)"
          }

          filterEl.appendChild(optionEl)
          state.filters[varName].elements.push(optionEl)
        }

        state.filtersContainer.appendChild(filterEl)
      }

      findNonEmptyFilterSubset()

      updateCirculatingAverageData()

      updateTitrePlot()
      updateTitreCladeAveragePlot()
    }
  }

  // NOTE(sen) Init body
  {
    let body = document.getElementsByTagName("body")[0]

    body.style.background = "var(--color-background)"
    body.style.color = "var(--color-text)"
    body.style.margin = "0"
    body.style.fontFamily =
      '-apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue",sans-serif'
  }

  // NOTE(sen) Init whole page container
  {
    let container = state.main
    container.style.display = "flex"
    container.style.flexDirection = "row"
  }

  // NOTE(sen) Init input container
  {
    let container = document.createElement("div")

    container.style.display = "flex"
    container.style.flexDirection = "column"
    container.style.alignItems = "left"
    container.style.width = state.sizes.inputBar
    container.style.marginRight = "10px"
    container.style.height = "100vh"
    container.style.overflowY = "scroll"
    container.style.overflowX = "hidden"
    container.style.flexShrink = "0"

    state.inputContainer = container
    state.main.appendChild(container)
  }

  // NOTE(sen) Init plot container
  {
    let container = document.createElement("div")

    container.style.display = "flex"
    container.style.flexDirection = "column"
    container.style.alignItems = "top"
    container.style.height = "calc(100vh - 0px)"
    container.style.overflowY = "scroll"
    container.style.overflowX = "hidden"

    let titrePlotContainer = document.createElement("div")
    let titreCladeAveragePlotContainer = document.createElement("div")
    let titreCirculatingAveragePlotContainer = document.createElement("div")

    titrePlotContainer.style.flexShrink = "0"
    titrePlotContainer.style.overflowX = "scroll"
    titrePlotContainer.style.overflowY = "hidden"

    titreCladeAveragePlotContainer.style.flexShrink =
      titrePlotContainer.style.flexShrink
    titreCladeAveragePlotContainer.style.overflowX =
      titrePlotContainer.style.overflowX
    titreCladeAveragePlotContainer.style.overflowY =
      titrePlotContainer.style.overflowY

    titreCirculatingAveragePlotContainer.style.flexShrink =
      titrePlotContainer.style.flexShrink
    titreCirculatingAveragePlotContainer.style.overflowX =
      titrePlotContainer.style.overflowX
    titreCirculatingAveragePlotContainer.style.overflowY =
      titrePlotContainer.style.overflowY

    container.appendChild(titreCirculatingAveragePlotContainer)
    container.appendChild(titreCladeAveragePlotContainer)
    container.appendChild(titrePlotContainer)

    state.titrePlotContainer = titrePlotContainer
    state.titreCladeAveragePlotContainer = titreCladeAveragePlotContainer
    state.titreCirculatingAveragePlotContainer =
      titreCirculatingAveragePlotContainer

    state.plotContainer = container
    state.main.appendChild(container)
  }

  // NOTE(sen) Init file input
  {
    let container = document.createElement("div")
    let input = document.createElement("input")
    input.setAttribute("type", "file")
    input.addEventListener("change", (event) => {
      let file = event.target.files[0]
      if (file !== null && file !== undefined) {
        state.fileSelectTextElement.innerHTML = file.name
        file.text().then(updateData)
      }
    })

    input.style.opacity = 0
    input.style.width = "100%"
    input.style.height = "100%"

    let label = document.createElement("div")
    label.innerHTML = "SELECT FILE"
    label.style.position = "absolute"
    label.style.top = "0px"
    label.style.left = "0px"
    label.style.textAlign = "center"
    label.style.width = "100%"
    label.style.height = "100%"
    label.style.lineHeight = "100px"
    label.style.fontWeight = "bold"
    label.style.letterSpacing = "2px"

    container.style.border = "1px dashed var(--color-fileSelectBorder)"
    container.style.width = "100%"
    container.style.height = label.style.lineHeight
    container.style.position = "relative"
    container.style.flexShrink = "0"
    container.style.boxSizing = "border-box"
    container.style.marginBottom = "20px"

    container.appendChild(label)
    container.appendChild(input)
    state.inputContainer.appendChild(container)
    state.fileSelectTextElement = label
  }

  // NOTE(sen) Init dark/light switch
  {
    let themeSwitch = document.createElement("div")

    themeSwitch.style.display = "flex"
    themeSwitch.style.flexDirection = "row"
    themeSwitch.style.marginBottom = "20px"
    themeSwitch.style.cursor = "pointer"

    let options = ["dark", "light"]
    let optionEls = []
    for (let option of options) {
      let optionEl = document.createElement("div")

      optionEl.innerHTML = option.toUpperCase()
      optionEl.style.padding = "5px"
      optionEl.style.border = "1px solid var(--color-border)"
      optionEl.style.flexGrow = "1"
      optionEl.style.textAlign = "center"
      optionEl.style.fontWeight = "bold"
      optionEl.style.letterSpacing = "2px"

      if (option === state.colors.theme) {
        optionEl.style.background = "var(--color-selected)"
      }

      themeSwitch.appendChild(optionEl)
      optionEls.push(optionEl)
    }

    themeSwitch.addEventListener("click", (event) => {
      let targetTheme = "dark"
      let selectionTarget = 0
      let inheritTarget = 1
      if (state.colors.theme === "dark") {
        targetTheme = "light"
        selectionTarget = 1
        inheritTarget = 0
      }
      state.colors.theme = targetTheme
      document.documentElement.setAttribute("theme", targetTheme)
      optionEls[selectionTarget].style.background = "var(--color-selected)"
      optionEls[inheritTarget].style.background = "inherit"
    })

    state.inputContainer.appendChild(themeSwitch)
  }

  // NOTE(sen) Init opacity inputs
  {
    let opacitiesEl = document.createElement("div")
    for (let varName of Object.keys(state.opacities)) {
      let opacityEl = document.createElement("div")
      opacityEl.innerHTML = varName.toUpperCase()

      opacityEl.addEventListener("click", (event) => {
        let targetOpacity = 0
        if (state.opacities[varName].value === 0) {
          targetOpacity = state.opacities[varName].default
        }

        state.opacities[varName].value = targetOpacity

        if (targetOpacity > 0) {
          event.target.style.background = "var(--color-selected)"
        } else {
          event.target.style.background = "inherit"
        }

        let alpha = colChannel255ToString(targetOpacity)
        let attrNames = ["stroke"]
        if (varName === "counts" || varName === "points") {
          attrNames = ["fill"]
        } else if (varName === "means") {
          attrNames.push("fill")
        }
        for (let [name, val] of Object.entries(state.opacities[varName])) {
          if (name.endsWith("Elements")) {
            for (let element of state.opacities[varName][name]) {
              for (let attrName of attrNames) {
                let currentColFull = element.getAttribute(attrName)
                let currentColNoAlpha = currentColFull.slice(0, 7)
                let newCol = currentColNoAlpha + alpha
                element.setAttributeNS(null, attrName, newCol)
              }
            }
          }
        }
      })

      opacityEl.style.cursor = "pointer"
      opacityEl.style.border = "1px solid var(--color-border)"
      opacityEl.style.textAlign = "center"
      opacityEl.style.padding = "5px"
      if (state.opacities[varName].value > 0) {
        opacityEl.style.background = "var(--color-selected)"
      }
      opacityEl.style.fontWeight = "bold"
      opacityEl.style.letterSpacing = "2px"

      opacitiesEl.appendChild(opacityEl)
    }

    opacitiesEl.style.marginBottom = "20px"

    state.inputContainer.appendChild(opacitiesEl)
    state.opacitiesContainer = opacitiesEl
  }

  // NOTE(sen) Init filters container
  {
    let filtersContainer = document.createElement("div")

    filtersContainer.style.display = "flex"
    filtersContainer.style.flexDirection = "row"
    filtersContainer.style.flexWrap = "wrap"

    state.filtersContainer = filtersContainer
    state.inputContainer.appendChild(filtersContainer)
  }

  // NOTE(sen) Init sliders
  {
    let sliders = document.createElement("div")
    sliders.style.marginBottom = "5px"
    state.slidersContainer = sliders
    state.inputContainer.appendChild(sliders)
  }

  // NOTE(sen) Dev only for now
  fetch("/data/data.csv")
    .then((resp) => resp.text())
    .then(updateData)
    .catch((e) => {})
</script>
